ifndef::leveloffset[]
:toc: left
:toclevels: 3
:icons: font
endif::[]

== Code examples

=== Type annotations

==== same types

[source,haskell]
----
Prelude> (+) 2 3 ::Double
5.0
----

==== different types

[source,haskell]
----
add_int_and_float :: Integer -> Float -> Float
add_int_and_float x y = fromIntegral(x) + y
main = do
    print(add_int_and_float 1 1.5)
----

.Results
* No type annotations
+
[source,haskell]
----
*Main> add_int_and_float 3 4.5
7.5
----

* NG: Both add type annotations as Integer
+
[source,haskell]
----
*Main> add_int_and_float 3 4.5 :: Integer

<interactive>:3:1: error:
    • Couldn't match expected type ‘Integer’ with actual type ‘Float’
    • In the expression: add_int_and_float 3 4.5 :: Integer
      In an equation for ‘it’: it = add_int_and_float 3 4.5 :: Integer
----

* Add type annotations as Float to right parameter
+
[source,haskell]
----
*Main> add_int_and_float 3 (4.5::Float)
7.5
----

* Add different type annotations to both variables
+
[source,haskell]
----
*Main> add_int_and_float (3::Integer) (4.5::Float)
7.5
----

=== Flow control statements

==== Loop using counter

* not using using guards
+
[source,haskell]
.loop_counter_no_guards.hs
----
main = do
    let loop 6 = return ()
        loop i = do
            print i
            loop (i + 1)
    loop 1
----
+
[source,haskell]
----
*Main> :load src/prelude/loop_counter_no_guards.hs
[1 of 1] Compiling Main             ( src/prelude/loop_counter_no_guards.hs, interpreted )
Ok, modules loaded: Main.
*Main> main
1
2
3
4
5
*Main>
----

* using guards
+
[source,haskell]
.loop_counter_using_guards.hs
----
main = do
    let loop i
          | i <= 5 = do
              print i
              loop (i + 1)
          | otherwise = return ()
    loop 1
----
+
[source,haskell]
----
*Main> :load src/prelude/loop_counter_using_guards.hs
[1 of 1] Compiling Main             ( src/prelude/loop_counter_using_guards.hs, interpreted )
Ok, modules loaded: Main.
*Main> main
1
2
3
4
5
*Main>
----

* loop 1 million
+
[source,haskell]
----
import Data.Time.Clock

main = do
    let sum_1million total
          | total < 10^6 = do
              sum_1million (total + 1)
          | otherwise = return total
    t0 <- getCurrentTime
    sum_1million 0 >>= print
    t1 <- getCurrentTime
    print (t1 `diffUTCTime` t0)
----
+
[source,haskell]
----
Prelude> :load src/prelude/loop_1million.hs
[1 of 1] Compiling Main             ( src/prelude/loop_1million.hs, interpreted )
Ok, modules loaded: Main.
*Main> main
1000000
3.0136357s
----
+
[source,console]
.No optimization: compiled with no flags with ghc
----
$ ../../bin/loop_1million
1000000
1.5058498s
----
+
[source,console]
.compiled with `-O2` flags with ghc
----
$ ../../bin/loop_1million
1000000
0.023587s
----
+
[NOTE]
Rust ではデバッグモードで 32ms, リリースビルドで 2µs ぐらい。
+
.References
* https://github.com/nh2/loop[Fast loops for Haskell (for when GHC can't optimize ... - GitHub^]
* https://www.channable.com/tech/how-we-made-haskell-search-strings-as-fast-as-rust[How we made Haskell search strings as fast as Rust^]

==== Loop using range

[source,haskell]
.loop_using_range.hs
----
main = do
    let loop is_true i n
          | is_true == True = do
              print i
              loop ((i + 1) < n) (i + 1) n
          | is_true /= True = return ()
    loop (1 < 6) 1 6
----

[source,haskell]
----
*Main> :load src/prelude/loop_using_range.hs
[1 of 1] Compiling Main             ( src/prelude/loop_using_range.hs, interpreted )
Ok, modules loaded: Main.
*Main> main
1
2
3
4
5
*Main>
----

==== Condition
[source,haskell]
----
Prelude> fact 5 == 120
True
Prelude>
----

==== List comprehension (リストの内包表記)

[source,haskell]
.3の倍数を抽出する
----
Prelude> [p | p <- [1..10], p `mod` 3 == 0]
[3,6,9]
Prelude>
----

[source,haskell]
.Making a list of divisors in Haskell
----
Prelude> [x | x <- [2..9], 10 `mod` x == 0]
[2,5]
Prelude>
----

[source,haskell]
.三乗根を抽出する
----
Prelude> [x | x <- [2..7], x * x * x == 8]
[2]
Prelude>
----

[source,haskell]
----
isPrime k = if k > 1 then null [ x | x <- [2..k - 1], k `mod` x == 0] else False
----

=== Functions

==== Single results

* using a single parameter
+
[source,haskell]
.A function that calculates the square of an integer
----
Prelude> let square x = x * x
Prelude> square 42
1764
Prelude>
----
+
[source,haskell]
.A function that calculates the factorial of a natural number
----
Prelude> let fact n = product [1..n]
Prelude> fact 5
120
Prelude> fact 10
3628800
Prelude>
----

* using multiple parameters
+
[source,haskell]
.add_2arg_int.hs
----
add :: Integer -> Integer -> Integer
add x y = x + y
main = do
    print(add 42 13)
----

* using tuple
+
[source,haskell]
----
add :: (Integer, Integer) -> Integer
add (x, y) = x + y
main = do
    print(add(42, 13))
----

==== Multiple results

[source,haskell]
.swap.hs
----
swap :: String -> String -> (String, String)
swap a b = (b, a)
main = do
    let (a, b) = swap "hello" "world"
    putStrLn (a ++ " " ++ b)
----

.Results
----
world hello
----

==== Higher-order function

* using arguments
+
[source,haskell]
.higher_order_tuple.hs
----
compute :: (Double -> Double -> Double) -> Double
compute f = f 3 4 ::Double

main = do
    let hypot = \x y -> sqrt (x^2 + y^2)
    print $ hypot 5 12
    print $ compute hypot
    print $ compute (**)
----

* using tuple
+
[source,haskell]
.higher_order_tuple.hs
----
compute :: ((Double, Double) -> Double) -> Double
compute (f) = f (3::Double, 4::Double)

hypot :: (Double, Double) -> Double
hypot (x, y) = sqrt (x^2 + y^2)

main = do
    print $ hypot(5, 12)
    print $ compute(hypot)
    print $ compute((\(x, y) -> x**y))
----

* using a anonymous function
+
[source,haskell]
.higher_order_tuple.hs
----
compute :: ((Double, Double) -> Double) -> Double
compute (f) = f (3::Double, 4::Double)

main = do
    let hypot = \(x, y) -> sqrt (x^2 + y^2)
    print $ hypot(5, 12)
    print $ compute(hypot)
    print $ compute((\(x, y) -> x**y))
----

=== Monad

[source,haskell]
----
Prelude> Just 1 >>= \x -> return (x*2)
Just 2
Prelude> Nothing >>= \x -> return (x*2)
Nothing
Prelude> [1,2,3] >>= \x -> return (x * 2)
[2,4,6]
Prelude>
----