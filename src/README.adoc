ifndef::leveloffset[]
:toc: left
:toclevels: 3
:icons: font
endif::[]

== Code examples

=== Type annotations

==== same types

[source,haskell]
----
Prelude> (+) 2 3 ::Double
5.0
----

==== different types

[source,haskell]
----
add_int_and_float :: Integer -> Float -> Float
add_int_and_float x y = fromIntegral(x) + y
main = do
    print(add_int_and_float 1 1.5)
----

.Results
* No type annotations
+
[source,haskell]
----
*Main> add_int_and_float 3 4.5
7.5
----

* NG: Both add type annotations as Integer
+
[source,haskell]
----
*Main> add_int_and_float 3 4.5 :: Integer

<interactive>:3:1: error:
    • Couldn't match expected type ‘Integer’ with actual type ‘Float’
    • In the expression: add_int_and_float 3 4.5 :: Integer
      In an equation for ‘it’: it = add_int_and_float 3 4.5 :: Integer
----

* Add type annotations as Float to right parameter
+
[source,haskell]
----
*Main> add_int_and_float 3 (4.5::Float)
7.5
----

* Add different type annotations to both variables
+
[source,haskell]
----
*Main> add_int_and_float (3::Integer) (4.5::Float)
7.5
----

=== Flow control statements

==== Condition
[source,haskell]
----
Prelude> fact 5 == 120
True
Prelude>
----

==== List comprehension (リストの内包表記)

[source,haskell]
.3の倍数を抽出する
----
Prelude> [p | p <- [1..10], p `mod` 3 == 0]
[3,6,9]
Prelude>
----

[source,haskell]
.Making a list of divisors in Haskell
----
Prelude> [x | x <- [2..9], 10 `mod` x == 0]
[2,5]
Prelude>
----

[source,haskell]
.三乗根を抽出する
----
Prelude> [x | x <- [2..7], x * x * x == 8]
[2]
Prelude>
----

[source,haskell]
----
isPrime k = if k > 1 then null [ x | x <- [2..k - 1], k `mod` x == 0] else False
----

=== Functions

==== Single results

* using a single parameter
+
[source,haskell]
.A function that calculates the square of an integer
----
Prelude> let square x = x * x
Prelude> square 42
1764
Prelude>
----
+
[source,haskell]
.A function that calculates the factorial of a natural number
----
Prelude> let fact n = product [1..n]
Prelude> fact 5
120
Prelude> fact 10
3628800
Prelude>
----

* using multiple parameters
+
[source,haskell]
.add_2arg_int.hs
----
add :: Integer -> Integer -> Integer
add x y = x + y
main = do
    print(add 42 13)
----

* using tuple
+
[source,haskell]
----
add :: (Integer, Integer) -> Integer
add (x, y) = x + y
main = do
    print(add(42, 13))
----

==== Multiple results

[source,haskell]
.swap.hs
----
swap :: String -> String -> (String, String)
swap a b = (b, a)
main = do
    let (a, b) = swap "hello" "world"
    putStrLn (a ++ " " ++ b)
----

.Results
----
world hello
----

==== Higher-order function

* using arguments
+
[source,haskell]
.higher_order_tuple.hs
----
compute :: (Double -> Double -> Double) -> Double
compute f = f 3 4 ::Double

main = do
    let hypot = \x y -> sqrt (x^2 + y^2)
    print $ hypot 5 12
    print $ compute hypot
    print $ compute (**)
----

* using tuple
+
[source,haskell]
.higher_order_tuple.hs
----
compute :: ((Double, Double) -> Double) -> Double
compute (f) = f (3::Double, 4::Double)

hypot :: (Double, Double) -> Double
hypot (x, y) = sqrt (x^2 + y^2)

main = do
    print $ hypot(5, 12)
    print $ compute(hypot)
    print $ compute((\(x, y) -> x**y))
----

* using a anonymous function
+
[source,haskell]
.higher_order_tuple.hs
----
compute :: ((Double, Double) -> Double) -> Double
compute (f) = f (3::Double, 4::Double)

main = do
    let hypot = \(x, y) -> sqrt (x^2 + y^2)
    print $ hypot(5, 12)
    print $ compute(hypot)
    print $ compute((\(x, y) -> x**y))
----

=== Monad

[source,haskell]
----
Prelude> Just 1 >>= \x -> return (x*2)
Just 2
Prelude> Nothing >>= \x -> return (x*2)
Nothing
Prelude> [1,2,3] >>= \x -> return (x * 2)
[2,4,6]
Prelude>
----