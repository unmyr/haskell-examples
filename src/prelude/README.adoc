== Code samples

==== Functions

===== Single results

* using parameters
+
[source,haskell]
.add_2arg_int.hs
----
add :: Integer -> Integer -> Integer
add x y = x + y
main = do
    print(add 42 13)
----

* using tuple
+
[source,haskell]
----
add :: (Integer, Integer) -> Integer
add (x, y) = x + y
main = do
    print(add(42, 13))
----

===== Multiple results

[source,haskell]
.swap.hs
----
swap :: String -> String -> (String, String)
swap a b = (b, a)
main = do
    let (a, b) = swap "hello" "world"
    putStrLn (a ++ " " ++ b)
----

.Results
----
world hello
----

===== Higher-order function

* using arguments
+
[source,haskell]
.higher_order_tuple.hs
----
compute :: (Double -> Double -> Double) -> Double
compute f = f 3 4 ::Double

main = do
    let hypot = \x y -> sqrt (x^2 + y^2)
    print $ hypot 5 12
    print $ compute hypot
    print $ compute (**)
----

* using tuple
+
[source,haskell]
.higher_order_tuple.hs
----
compute :: ((Double, Double) -> Double) -> Double
compute (f) = f (3::Double, 4::Double)

hypot :: (Double, Double) -> Double
hypot (x, y) = sqrt (x^2 + y^2)

main = do
    print $ hypot(5, 12)
    print $ compute(hypot)
    print $ compute((\(x, y) -> x**y))
----

* using a anonymous function
+
[source,haskell]
.higher_order_tuple.hs
----
compute :: ((Double, Double) -> Double) -> Double
compute (f) = f (3::Double, 4::Double)

main = do
    let hypot = \(x, y) -> sqrt (x^2 + y^2)
    print $ hypot(5, 12)
    print $ compute(hypot)
    print $ compute((\(x, y) -> x**y))
----
